<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Jasberyon.GitHub.io by Jasber-Yon</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Jasberyon.GitHub.io</h1>
      <h2 class="project-tagline">Jasberyon的博客</h2>
      <a href="https://github.com/Jasber-Yon/jasberyon.github.io" class="btn">View on GitHub</a>
      <a href="https://github.com/Jasber-Yon/jasberyon.github.io/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/Jasber-Yon/jasberyon.github.io/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="java8新特性小结-接口与lambda表达式" class="anchor" href="#java8%E6%96%B0%E7%89%B9%E6%80%A7%E5%B0%8F%E7%BB%93-%E6%8E%A5%E5%8F%A3%E4%B8%8Elambda%E8%A1%A8%E8%BE%BE%E5%BC%8F" aria-hidden="true"><span class="octicon octicon-link"></span></a>Java8新特性小结-接口与Lambda表达式</h1>

<p>Java8的新特性相对于前版本（Java7）来说，主要体现在两个方面：
1．   接口定义与使用
2．   Lambda表达式对匿名内部类的简化使用。</p>

<p>Java8新特性的具体表现如下：
1.在接口中的体现
（1）在接口中可以定义实体方法，但除原先的抽象方法外只能定义两种方法：
A．公共的静态方法
如：
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public interface InterfaceA {  </p>

<pre><code>public static void sayHi(){  
    System.out.println("InterfaceA---sayHi");  
}  
</code></pre>

<p>}  </p>

<p>需要注意的是：
a．由于静态方法是属于类（文件）的，所以调用时需要使用对应的接口（静态方法所在类）名去调用。所以在Java8中调用接口中静态方法时，只能通过接口名去调用，使用实现类是无法调用的。</p>

<p>B．使用default关键字声明的普通方法
如：
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public interface InterfaceA {  </p>

<pre><code>public default void sayHi2(){  
    System.out.println("InterfaceA---sayHi2");  
}  
</code></pre>

<p>}<br>
  </p>

<p>需要注意的是：
b．default关键字只能在接口中使用。那么当在接口的具体实现类中重写该default关键之标识的方法时就需要去掉default关键字。如：
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public class InterfaceImpl implements InterfaceA {  </p>

<pre><code>public static void main(String[] args){  
    InterfaceA.sayHi();  
    InterfaceImpl.sayHi();  
}  

public static void sayHi(){  
    System.out.println("InterfaceImpl---sayHi");  
}  

public void sayHi2(){  
    System.out.println("InterfaceB---sayHi2");  
}  
</code></pre>

<p>}  </p>

<p>在上面的代码情况（重写接口中的default关键字标识的方法）下当多态调用时，同样会走现实类（子类）的方法，如果没有重写，则走接口中的default方法。
例如：
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public class InterfaceImpl implements InterfaceA {  </p>

<pre><code>public static void main(String[] args){  
    InterfaceA.sayHi();  
    InterfaceImpl.sayHi();  
    InterfaceA ia = new InterfaceImpl();  
    ia.sayHi2();  
}  

public static void sayHi(){  
    System.out.println("InterfaceImpl---sayHi");  
}  

public void sayHi2(){  
    System.out.println("InterfaceB---sayHi2");  
}  
</code></pre>

<p>}<br>
输出结果：
InterfaceA---sayHi
InterfaceImpl---sayHi
InterfaceB---sayHi2
注意： 因为在Java中类是单继承的，而接口却是可以多实现的。这样这几的初衷是出于安全性的考虑。因为在多继承的模式中，如果子类C继承了父类A和B，而A和B中又有相同的方法methodAlike。那么这时就无法区分子类C中使用方法时到底是使用哪一父类中的方法了。而（原先的设计）接口则不同，实现类需要实现接口中定义的方法，则不存在上述的安全性问题。</p>

<p>那么，现在的问题是：由于在Java8的新特性中可以在接口中定义非静态的方法，那么当多个接口中定义了相同的非静态default方法时，如果实现类实现了这多个接口时，是不是就出现了多继承了呢？
答案是否定的</p>

<p>这时就会产生编译时错误，需要在实现类中覆盖相同的接口中定义的所有方法方法。</p>

<p>如：
定义接口InterfaceA
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public interface InterfaceA {  </p>

<pre><code>public static void sayHi(){  
    System.out.println("InterfaceA---sayHi");  
}  

public default void sayHi2(){  
    System.out.println("InterfaceA---sayHi2");  
}  
</code></pre>

<p>}  </p>

<p>定义接口InterfaceB
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public interface InterfaceB {  </p>

<pre><code>public static void sayHi(){  
    System.out.println("InterfaceB---sayHi");  
}  

public default void sayHi2(){  
    System.out.println("InterfaceB---sayHi2");  
}  
</code></pre>

<p>}  </p>

<p>那么此时就会发现接口InterfaceA和InterfaceB中有相同的方法：public defaultvoidsayHi2()，那么此时实现类就必须去重写相同的方法。</p>

<p>实现类InterfaceImpl
[java] view plaincopy
package com.jasberyon.java8.interfacer;  </p>

<p>public class InterfaceImpl implements InterfaceA, InterfaceB {  </p>

<pre><code>public static void sayHi(){  
    System.out.println("InterfaceImpl---sayHi");  
}  

public void sayHi2(){  
    System.out.println("InterfaceB---sayHi2");  
}  
</code></pre>

<p>}  </p>

<p>小结：Java的接口本身就是一种为扩展程序而使用的，在Java8中应该避免让实现类去覆盖具有多个相同default方法的接口，这样没有什么意义。Java8在接口中的新特性仅作为一个扩展而使用。而对于接口中的静态方法，在实现类中去“重写”（实际上不是）是没有意义的。</p>

<ol>
<li>Lambda表达式对匿名内部类的简化使用
Lambda表达式替换了原有的匿名内部类的写法，简化了匿名内部类的使用方式。当然简化的方式总是会使得功能使用时有所限制，Just like 增强型for（for-each）循环。</li>
</ol>

<p>Lambda表达式的语法结构：
(参数1，参数2...)-&gt;{
    重写方法内容，不写定义方法名。
}</p>

<p>（1）多线程时使用Lambda表达式</p>

<p>原来的使用匿名内部类实现多线程的栗子：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>public class ThreadDemo {  </p>

<pre><code>public static void main(String[] args) {  

    new Thread(new Runnable() {  
        @Override  
        public void run() {  
            for(int i=0; i&lt;200; i++){  
                System.out.println("执行run---------"+i);  
            }  

        }  
    }).start();  

    for(int j=0; j&lt;200; j++){  
        System.out.println("执行mian---------------"+j);  
    }  

}  
</code></pre>

<p>}  </p>

<p>使用Lambda表达式改造后：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>public class ThreadDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Runnable runnable = ()-&gt;{  
        for(int i=0; i&lt;200; i++){  
            System.out.println("执行run---------"+i);  
        }  
    };  
    new Thread(runnable).start();  

    for(int j=0; j&lt;200; j++){  
        System.out.println("执行mian---------------"+j);  
    }     

}  
</code></pre>

<p>}  </p>

<p>又或者这样写：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>public class ThreadDemo {  </p>

<pre><code>public static void main(String[] args) {  

    new Thread(()-&gt;{  
        for(int i=0; i&lt;200; i++){  
            System.out.println("执行run---------"+i);  
        }  
    }).start();  

    for(int j=0; j&lt;200; j++){  
        System.out.println("执行mian---------------"+j);  
    }  
}  
</code></pre>

<p>}  </p>

<p>那么，Lambda的弊端也是显而易见的，如果接口中定义了多个抽象方法，那么就只能使用传统方式了。</p>

<p>（2）集合排序“比较器”中使用Lambda表达式</p>

<p>TreeSet会将字符串按照自然顺序进行排序，如下代码：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>import java.util.Set;<br>
import java.util.TreeSet;  </p>

<p>public class TreeSetDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Set&lt;String&gt; set = new TreeSet&lt;String&gt;();  
    set.add("asdafa");  
    set.add("abcdefsadf");  
    set.add("sahdfoad");  
    set.add("bhsayuadasdfasdf");  
    set.add("auiweyqwergeawgfasdasd");  
    System.out.println(set);  
}  
</code></pre>

<p>}  </p>

<p>结果输出：
[abcdefsadf, asdafa,auiweyqwergeawgfasdasd, bhsayuadasdfasdf, sahdfoad]</p>

<p>使用自定义的比较器后：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>import java.util.Comparator;<br>
import java.util.Set;<br>
import java.util.TreeSet;  </p>

<p>public class TreeSetDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Set&lt;String&gt; set = new TreeSet&lt;String&gt;(new MyCompareMethod());  
    set.add("asdafa");  
    set.add("abcdefsadf");  
    set.add("sahdfoad");  
    set.add("bhsayuadasdfasdf");  
    set.add("auiweyqwergeawgfasdasd");  
    System.out.println(set);  
}  
</code></pre>

<p>}  </p>

<p>class MyCompareMethod implements Comparator{  </p>

<pre><code>@Override  
public int compare(String o1, String o2) {  
    int length = o1.length() - o2.length();  
    return length == 0?o1.compareTo(o2):length;  
}  
</code></pre>

<p>}  </p>

<p>结果输出：
[asdafa, sahdfoad, abcdefsadf,bhsayuadasdfasdf, auiweyqwergeawgfasdasd]</p>

<p>使用匿名内部类后：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>import java.util.Comparator;<br>
import java.util.Set;<br>
import java.util.TreeSet;  </p>

<p>public class TreeSetDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Set&lt;String&gt; set = new TreeSet&lt;String&gt;(new Comparator&lt;String&gt;(){  
        @Override  
        public int compare(String o1, String o2) {  
            int length = o1.length() - o2.length();  
            return length == 0?o1.compareTo(o2):length;  
        }  
    });  
    set.add("asdafa");  
    set.add("abcdefsadf");  
    set.add("sahdfoad");  
    set.add("bhsayuadasdfasdf");  
    set.add("auiweyqwergeawgfasdasd");  
    System.out.println(set);  
}  
</code></pre>

<p>}  </p>

<p>使用Lambda表达式改造：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>import java.util.Set;<br>
import java.util.TreeSet;  </p>

<p>public class TreeSetDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Set&lt;String&gt; set = new TreeSet&lt;String&gt;((String o1, String o2)-&gt;{  
        int length = o1.length() - o2.length();  
        return length == 0?o1.compareTo(o2):length;  
    });  
    set.add("asdafa");  
    set.add("abcdefsadf");  
    set.add("sahdfoad");  
    set.add("bhsayuadasdfasdf");  
    set.add("auiweyqwergeawgfasdasd");  
    System.out.println(set);  
}  
</code></pre>

<p>}  </p>

<p>也可写成：
[java] view plaincopy
package com.jasberyon.java8.lambda;  </p>

<p>import java.util.Set;<br>
import java.util.TreeSet;  </p>

<p>public class TreeSetDemo {  </p>

<pre><code>public static void main(String[] args) {  

    Set&lt;String&gt; set = new TreeSet&lt;String&gt;((o1, o2)-&gt;{  
        int length = o1.length() - o2.length();  
        return length == 0?o1.compareTo(o2):length;  
    });  
    set.add("asdafa");  
    set.add("abcdefsadf");  
    set.add("sahdfoad");  
    set.add("bhsayuadasdfasdf");  
    set.add("auiweyqwergeawgfasdasd");  
    System.out.println(set);  
}  
</code></pre>

<p>}  </p>

<p>值得注意的是，此时需要泛型标注。也就是比较的类型必须在&lt;&gt;中声明，否则无法通过编译。</p>

<p>同时，使用Lambda表达式的实现不会再有额外的类文件（原来的方式匿名内部类也是要产生形如Ttt$xx.class的文件的）产生。</p>

<p>其它的还有很多就不在列举了。记住一点，构造匿名内部类时，如果只有一个方法需要重写，那么就可以使用Lambda表达式。</p>

<p><a href="http://blog.csdn.net/miner_jasber_yon/">我的CSDN博客</a></p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/Jasber-Yon/jasberyon.github.io">Jasberyon.GitHub.io</a> is maintained by <a href="https://github.com/Jasber-Yon">Jasber-Yon</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
